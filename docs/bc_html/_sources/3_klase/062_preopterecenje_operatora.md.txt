# Преоптерећење оператора у класи

У литератури о програмском језику C# наићи ћеш на изразе "преклапање оператора" и
"преоптерећење оператора" - у питању су само различити преводи енглеског израза
*operator overloading*.

Предефинисани C# оператори се могу преоптеретити дефинисањем посебних статичких
метода унутар класа помоћу кључне речи `operator` и навођењем типа оператора
који се преоптерећује.

Нека је задатак да креираш класу `Kompleksni` која представља комплексне
бројеве и програм за сабирање комплексних бројева који ту класу користи.
Комплексни бројеви нису "обични" бројеви јер имају реални и имагинарни део. То
значи да оператор `+` треба дефинисати тако да може да сабира бројеве који се
састоје из два дела.

```cs
using System;

public class Kompleksni
{
    public double Re { get; set; }
    public double Im { get; set; }

    public Kompleksni(double realni, double imaginarni)
    {
        Re = realni;
        Im = imaginarni;
    }

    public static Kompleksni operator +(Kompleksni k1, Kompleksni k2)
    {
        return new Kompleksni(k1.Re + k2.Re, k1.Im + k2.Im);
    }

    public void Ispis()
    {
        Console.WriteLine($"{Re} + {Im}i");
    }
}
```

Класа `Kompleksni` треба да има два поља која представљају реални и имагинарни
део комплексног броја и конструктор којим се та поља иницијализују. Посебна
статичка метода у класи `Kompleksni` којом се преоптерећује оператор `+` треба
да прихвати два, а врати један комплексан број који представља њихов збир.

Програм у којем се користи класа `Kompleksni` и преоптерећени оператор `+`
за сабирање комплексних бројева може да изгледа овако:

```cs
class Program
{
    static void Main()
    {
        Kompleksni k1 = new Kompleksni(3.0, 4.0);
        Kompleksni k2 = new Kompleksni(1.0, 2.0);
        Kompleksni k3 = k1 + k2;
        k3.Ispis();
    }
}
```

Ако би следећи задатак био да се класом `Kompleksni` омогући и одузимање
комплексних бројева, у класи би требало написати и посебан статички метод за
преоптерећење оператора `-`, на пример:

```cs
public static Kompleksni operator -(Kompleksni k1, Kompleksni k2)
{
    return new Kompleksni(k1.Re - k2.Re, k1.Im - k2.Im);
}
```

Аритметички оператори нису једини оператори који се могу преоптеретити. Списак
свих оператора приказан је у следећој табели:

| Оператори                                   | Напомена                        |
|---------------------------------------------|---------------------------------|
| `+x`, `-x`, `!x`, `~x`, `++`, `--`          |                                 |
| `true`, `false`                             | Морају се преоптеретити заједно |
| `x + y`, `x - y`, `x * y`, `x / y`, `x % y` |                                 |
| `x & y`, `x \| y`, `x ^ y`                  |                                 |
| `x << y`, `x >> y`, `x >>> y`               |                                 |
| `x == y`, `x != y`                          | Морају се преоптеретити заједно |
| `x < y`, `x > y`                            | Морају се преоптеретити заједно |
| `x <= y`, `x >= y`                          | Морају се преоптеретити заједно |

Логично је да неке операторе треба преоптеретити у пару. На пример, ако класа
`Kompleksni` треба да обезбеди функционалност упоређивања једнакости
комплексних бројева, онда треба да преоптеретиш операторе `==` и `!=`, на
пример овако:

```cs
public static bool operator ==(Kompleksni k1, Kompleksni k2)
{
    return k1.Re == k2.Re && k1.Im == k2.Im;
}

public static bool operator !=(Kompleksni k1, Kompleksni k2)
{
    return !(k1 == k2);
}
```

Пошто си преоптеретио операторе `==` и `!=`, требало би да преоптеретиш и методе
`Equals()` и `GetHashCode()`:

```cs
public override bool Equals(object obj)
{
    if (obj is Kompleksni)
    {
        var other = (Kompleksni)obj;
        return this == other;
    }
    return false;
}

public override int GetHashCode()
{
    return Re.GetHashCode() ^ Im.GetHashCode();
}
```

Иако `true` и `false` нису оператори већ литерали типа `bool`, ако се говори о
преоптерећењу "оператора" `true` и `false`, онда се мисли на то како се `true`
и `false` користе за прилагођавање понашања класа у контексту условних израза
попут `if` или `while`. Значи, могу `true` и `false` можеш преоптеретити за
класе, како би дефинисао логичку истинитост објекта класе.

У табели која следи наведени су предефинисани оператори који се не могу
експлицитно преоптеретити, или се не могу уопште преоптеретити.

| Оператори                                                                          | Напомена                                  |
|------------------------------------------------------------------------------------|-------------------------------------------|
| `x && y`, `x \|\| y`                                                               | Преоптерети `true`, `false`, `&` и `\|`   |
| `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `\|=`, `^=`, `<<=`, `>>=`, `>>>=`              | Преоптерети одговарајући бинарни оператор |
| `^x`, `x = y`, `x.y`, `x?.y`, `c ? t : f`, `x ?? y`, `??= y`, `x..y`, `x->y`, `=>` | Не могу да се преоптерете                 |
