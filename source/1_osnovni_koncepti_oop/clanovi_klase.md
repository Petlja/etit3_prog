# Чланови класе

Класе имају чланове (енгл. *Members*) којима се представљају њихови подаци и
понашање (уместо термина "чланови класе", у литератури на српском језику може
се наићи и на термин "елементи класе"). Чланови класе могу бити:

* поља (енгл. *Fields*),
* константе (енгл. *Constants*),
* методе (енгл. *Methods*),
* својства (енгл. *Properties*),
* конструктори (енгл. *Constructors*),
* догађаји (енгл. *Events*),
* преоптерећени оператори (енгл. *Overloadable Operators*),
* индексери (енгл. *Indexers*),
* угнежђени типови (енгл. *Nested Types*) и
* финализатори (енгл. *Finalizers*).

## Поља

Поља су променљиве декларисане у опсегу класе. Поље може бити неког уграђеног
типа или инстанца друге класе. Пољима се обично представљају подаци ентитета
класе. На пример, поља класе `Trougao` могу бити променљиве којима се
представљају странице троугла:

```cs
class Trougao
{
    public double a;
    public double b;
    public double c;
}
```

Да би приступио дефинисам пољима у главном програму, потребно је да
инстанцираш један објекат класе `Trougao`, па поставиш иницијалне вредности
поља. Након тога можеш да им приступаш, мењаш их, исписујеш итд. На пример:

```cs
Trougao t1 = new Trougao() { a = 3.0, b = 4.0, c = 4.0 };
t1.c = 5.0;
Console.WriteLine("Obim trougla je: {0}", t1.a + t1.b + t1.c);
```

У примеру изнад инстанциран је објекат `t1` класе `Trougao` са иницијалним
вредностима поља: $a=3.0$, $b=4.0$ и $c=4.0$. Потом је вредност поља `c`
објекта `t1` (`t1.c`) промењена на `5.0`. У последњој линији у конзоли је
исписан обим троугла тј. збир вредности поља `a`, `b` и `c` објекта `t1`.

## Константе

Константе су поља чија је вредност унапред задата у програму и која се не може
мењати. На пример, класу `Krug` можеш дефинисати на следећи начин:

```cs
class Krug
{
    public double r;
    public const double pi = 3.14159265359;
}
```

Ради прецизности, у овом случају боље је да вредност константе дефинишеш помоћу
уграђене константе `Math.PI`, него да ручно уносиш децимале:

```cs
public const double pi = Math.PI;
```

У главном програму можеш да инстанцираш један објекат класе `Krug` и пољу `r`
доделиш иницијалну вредност. Дефинисану константу `pi` можеш користити као
константу константу класе `Krug` (`Krug.pi`), на пример, приликом рачунања
обима круга:

```cs
Krug k1 = new Krug() { r = 5.0 };
Console.WriteLine("Obim kruga je: {0}", 2 * Krug.pi * k1.r);
```

## Методе

Методе дефинишу радње које класа може да изврши. Методе могу да приме аргументе
дефинисане параметрима, могу да врате податке кроз параметре и могу да врате
вредност директно без коришћења параметара. Једноставан пример методе био би да
у класи `Krug` креираш методу за рачунање обима круга:

```cs
class Krug
{
    public double r;
    public const double pi = Math.PI;

    public double Obim()
    {
        return 2 * r * pi;
    }
}
```

Ова метода нема параметре и враћа вредност директно. У главном програму можеш
да, након инстанцирања објекта `k1` класе `Krug` и доделе иницијалне вредности
пољу `r`, позовеш методу `Obim()` објекта `k1` која ће вратити вредност обима
круга.

```cs
Krug k1 = new Krug() { r = 5.0 };
Console.WriteLine("Obim kruga je: {0}", k1.Obim());
```

## Својства

Својства су методе класе којима се приступа као да су поља класе. На пример,
методу `Obim()` класе `Krug` можеш дефинисати тако да јој се приступа као да је
поље класе. Зашто онда не би, једноставно, дефинисао обим као још једно поље,
на пример `public double O;`? Ако нека величина може да се израчуна на основу
осталих чланова класе, онда није добра пракса да се та величина дефинише као
поље. У овом случају, обим може да се израчуна на основу полупречника и
константе `pi`, те нема потребе да мануелно рачунаш и уносиш и вредност обима
круга.

Значи, својство може да обезбеди заштиту за поље класе како би се спречило да
се његова вредност мења мануелно. У дефиницији својства обично се користе
методе `get()` и `set()` које служе за добављање, односно постављање вредности.
О њима ћеш детаљно учити у наредним поглављима. У примеру изнад, методом
`get()` могле би се добавити вредности полупречника `r` и константе `pi` и
вратити израчуната вредност обима круга:

```cs
class Krug
{
    public double r;
    public const double pi = Math.PI;
    public double O { get { return 2 * pi * r; } }
}
```

У главном програму можеш да, након инстанцирања објекта `k1` класе `Krug` и
доделе иницијалне вредности пољу `r`, приступиш својсту `O` објекта `k1` на
следећи начин:

```cs
Krug k1 = new Krug() { r = 5.0 };
Console.WriteLine("Obim kruga je: {0}", k1.O);
```

## Конструктори

Конструктори су специјалне методе које се користе приликом инстанцирања
објеката класе. Имају исто име као и класа у којој су дефинисани и враћају
објекат те класе. Конструктори могу имати различите облике:

* **Подразумевани конструктор без параметара** креира сам компајлер у
случајевима када класа нема дефинисане конструкторе. То се дешавало у свим
досадашњим примерима.
* **Параметаризовани конструктор** прихвата аргументе који се користе за
иницијализацију поља.
* **Конструктор копије** креира нови објекат као копију постојећег објекта.

Конструктор дефинисан од стране компајлера називају се **имплицитни**
конструктор, док се конструктори дефинисани од стране програмера називају
**експлицитни** конструктори.

Користећи параметаризовани конструктор, класу `Krug` можеш да дефинишеш на
следећи начин:

```cs
class Krug
{
    public double r;
    public const double pi = Math.PI;

    public Krug(double radius)
    {
        r = radius;
    }

    public double Obim()
    {
        return 2 * pi * r;
    }
}
```

У главном програму, вредност полупречника сада наводиш као параметар приликом
инстанцирања објекта `k1` класе `Krug`. Тип параметра одређен је у дефиницији
конструктора. Конструктор `Krug` прима полупречник круга као аргумент и
поставља вредност поља `r`.

```cs
Krug k1 = new Krug(5.0);
Console.WriteLine("Obim kruga je: {0}", k1.Obim());
```

Једна класа може да има више дефинисаних конструктора. Они могу да се разликују
по броју, типу и редоследу аргумената које прихватају. На пример, класа која
служи за рачунање обима правоуглог троугла `Pravougli` може да буде дефинисана
на следећи начин:

```cs
class Pravougli
{
    public double a;
    public double b;
    public double c;

    public Pravougli() { }

    public Pravougli(double katetaA, double katetaB)
    {
        a = katetaA;
        b = katetaB;
        c = Math.Sqrt(katetaA * katetaA + katetaB * katetaB);
    }

    public Pravougli(double hipotenuza, double ugaoA, double ugaoB)
    {
        a = (hipotenuza * Math.Sin(ugaoA));
        b = (hipotenuza * Math.Sin(ugaoB));
        c = hipotenuza;
    }

    public double Obim()
    {
        return a + b + c;
    }
}
```

Први контруктор дефинисан је без параметара. Инстанцирање објекта `p1` класе
`Pravougli` помоћу тог конструктора и израчунавање обима може, у главном
програму, да изгледа овако:

```cs
Pravougli p1 = new Pravougli() { a = 3.0, b = 4.0, c = 5.0};
Console.WriteLine("Obim trougla je: {0}", p1.Obim());
```

Параметри другог конструктора су дужине катета правоуглог троугла. Дужина
хипотенузе израчунава се на основу дужина катета по Питагориној теореми.
Инстанцирање објекта `p2` класе `Pravougli` помоћу тог конструктора и
израчунавање обима може, у главном програму, да изгледа овако:

```cs
Pravougli p2 = new Pravougli(3.0, 4.0);
Console.WriteLine("Obim trougla je: {0}", p2.Obim());
```

Параметри трећег конструктора су дужине хипотенузе и оштри углови правоуглог
троугла задати у радијанима. Дужина катета израчунава се по формули
$hipotenuza\times{sin{(ugao)}}$. Инстанцирање објекта `p3` класе `Pravougli`
помоћу тог конструктора и израчунавање обима може, у главном програму, да
изгледа овако:

```cs
Pravougli p3 = new Pravougli(5.0, 0.64, 0.93);
Console.WriteLine("Obim trougla je: {0}", p3.Obim());
```

## Догађаји, преоптерећени оператори, индексери, финализатори и угнежђени типови

Следећи чланови класа биће само поменути у овој лекцији, а више о њима учићеш у
наредним поглављима:

* **Догађаји** представљају механизам за обраду регистрованих активности у
програму, као што су клик на дугме, измена текста у оквиру за текст или нека
друга корисничка или системска активност. Они омогућавају класама да
обавештавају друге делове програма о тим активностима. Такође, програмери могу
дефинисати сопствене догађаје у својим класама.
* **Преоптерећени оператори** су методе који омогућавају да се стандардни
оператори користе са кориснички дефинисаним типовима података. Коришћењем
преоптерећених оператора, програмери могу да дефинишу како оператори раде са
њиховим класама, што омогућава већу флексибилност у програмирању.
* **Индексери** омогућују да се објекти индексирају на начин сличан индексирању
низова. Дефинишу се као методе класе помоћу кључне речи `this`, типом индекса и
методама `get()` и `set()`.
* **Угнежђени типови** су типови декларисани унутар класе. Они могу бити било
који валидан тип података, укључујући основне типове, класе, структуре, низове
итд. Користе се када је потребно да се ограничи коришћење типа или организује
нека логичка структура података унутар класе.
* **Финализатори**, раније познати као **деструктори** (енгл. *destructors*),
се данас веома ретко користе у програмском језику C#. То су методе које се
позивају у тренутку када објекат треба да буде уклоњен из меморије, у циљу
руковања ресурсима који треба да се ослободе. Више их нећемо помињати.

Из ове лекције важно је да запамптиш следеће:

```{infonote}
Класе имају **чланове** којима се представљају њихови подаци и понашање:

* **Поља** су променљиве одређеног типа декларисане у опсегу класе којима се
обично представљају подаци ентитета класе.
* **Константе** су поља чија је вредност унапред задата у програму и која се не
може мењати.
* **Методе** дефинишу радње које класа може да изврши. Оне могу да приме
аргументе дефинисане параметрима, могу да врате податке кроз параметре и могу
да врате вредност директно без коришћења параметара.
* **Својства** су методе којима се приступа као да су поља, а у њиховој
дефиницији користе се методе за добављање и постављање вредности.
* **Конструктори** су специјалне методе које се користе приликом инстанцирања
објеката. Носе исто име као и класа у којој су дефинисани и враћају објекат те
класе. Подразумевани конструктор без параметара креира компајлер када класа
нема дефинисане конструкторе. Параметаризовани конструктор прихвата аргументе
који се користе за иницијализацију поља. Једна класа може да има више
конструктора. Конструктор дефинисан од стране компајлера називају се
**имплицитни** конструктор, док се конструктори дефинисани од стране програмера
називају **експлицитни** конструктори.
```
