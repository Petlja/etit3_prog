# Енкапсулација

Енкапсулација је одлика ООП која омогућује контролу приступа члановима класе.
Представља један од основних принципа објектно-оријентисаног програмирања.
Реализује се коришћењем **модификатора приступа** (енгл. *Access Modifiers*).
Сви чланови класе имају дефинисан **ниво приступачности**. Он контролише да ли
се члан класе може користити од стране кода у оквиру истог или различитог
склопа. Склоп (енгл. *Assembly*) може бити извршни *.exe* фајл или библиотека
динамичких веза тј. *.dll* фајл, настао једним компајлирањем једног или више
изворних C# фајлова, тј. *.cs* фајлова.

Постоје следећи модификатори приступа:

* `public`,
* `private`,
* `protected`,
* `internal`,
* `protected internal`,
* `private protected` и
* `file`.

Ниво приступачности члановима класа најлакше се може представити следећом
табелом:

| Локација                       | `public` | `protected internal` | `protected` | `internal` | `private protected` | `private` | `file` |
|--------------------------------|--------|--------------------|-----------|----------|-------------------|---------|------|
| У фајлу                        | ✔️        | ✔️                    | ✔️           | ✔️          | ✔️                   | ✔️         | ✔️      |
| У класи                        | ✔️        | ✔️                    | ✔️           | ✔️          | ✔️                   | ✔️         | ❌      |
| Изведена класа, исти склоп     | ✔️        | ✔️                    | ✔️           | ✔️          | ✔️                   | ❌         | ❌      |
| Не-изведена класа, исти склоп  | ✔️        | ✔️                    | ❌           | ✔️          | ❌                   | ❌         | ❌      |
| Изведена класа, други склоп    | ✔️        | ✔️                    | ✔️           | ❌          | ❌                   | ❌         | ❌      |
| Не-изведена класа, други склоп | ✔️        | ❌                    | ❌           | ❌          | ❌                   | ❌         | ❌      |

Вероватно се питаш зашто би се ограничавао ниво приступа члановима класе?
Зар није најбоље све чланове класе учинити доступним свима и свуда? Одговор је
једноставан - није! Неки од многих разлога су:

* **Скривање детаља имплементације**: Ограничавањем приступа члановима класе,
скривају се детаљи имплементације класе од спољног утицаја. Тиме се спречавају
други делови програма да директно приступају члановима класе или их мењају, што
чува целовитост и конзистентност података. На пример, ако на основу чланова
класе који представљају катете `a` и `b` правоуглог троугла треба да се рачуна
обим троугла, онда члан класе који представља хипотенузу `c` не треба да буде
приступачан - вредност члана `c` израчунаће се у класи.
* **Побољшање безбедности**: Ограничавање приступа најосетљивијим деловима кода
смањује се ризик од неовлашћене манипулације подацима. На пример, нема потребе
да се из сваког дела програма приступа корисничким подацима за аутентификацију
и ауторизацију (корисничка имена, лозинке и сл.) - то је чак изузетно ризично!
Могућност приступа тим подацима треба да имају само класе којима се врши
аутентификација и ауторизација.
* **Олакшавање одржавања и развоја**: Контрола приступа чини класу модуларном и
омогућава извршавање измена унутар класе без утицаја на друге делове програма.
Промене у интерним детаљима класе могу се вршити без потребе за изменама у коду
који користи ту класу. На пример, нека се у некој класи коначна цена артикла у
продавници израчунава тако што се сабере основна цена артикла са производом
основне цене артикла и стопом ПДВ-а. Ако се стопа ПДВ-а промени, ту промену
треба унети једном, само у тој класи.
* **Флексибилност и поновна употреба кода**: Једном написана и тестирана класа
може се користити у различитим деловима програма без потребе за поновним
писањем и тестирањем. На пример, класа за израчување просека оцена и одређивање
успеха ученика може се користити приликом приказа статистике ученика, успеха
одељена, штампања сведочанстава итд.

У овом уводном поглављу највише треба да обратиш пажњу на два модификатора
приступа - `public` и `private`.

До сада се у свим примерима користио модификатор приступа `public` приликом
дефинисања чланова класе. Имајући у виду горе наведене разлоге за ограничавањем
приступа члановима класе, можеш да закључиш да **то није добро**! На пример,
шта није добро у следећој класи?

```cs
class Pravougli
{
    public double a;
    public double b;
    public double c;

    public Pravougli(double katetaA, double katetaB)
    {
        a = katetaA;
        b = katetaB;
        c = Math.Sqrt(katetaA * katetaA + katetaB * katetaB);
    }

    public double Obim()
    {
        return a + b + c;
    }
}
```

Да би троугао био правоугли, мора да важи Питагорина теорема. У коду програма
то је обезбеђено израчунавањем вредности хипотенузе у конструктору. Ако се
класи приступи на следећи начин...

```cs
Pravougli p1 = new Pravougli(3.0, 4.0);
Console.WriteLine("Obim trougla je: {0}", p1.Obim());
```

...неће бити проблема. Израчунаће се хипотенуза дужине $5$ и обим $3+4+5=12$.
Међутим, како су сва поља у класи јавна, класи се може приступити и овако...

```cs
Pravougli p2 = new Pravougli(3.0, 4.0) { a = 3, b = 3, c = 3};
Console.WriteLine("Obim trougla je: {0}", p2.Obim());
```

...па ће се обим рачунати као $3+3+3=9$! Зашто? Приликом инстанцирања објекта
`p2` конструктором су постављене вредности поља `а = 3` и `b = 4` и израчуната
је вредност поља `c = 5` по формули $c=\sqrt{a^2+b^2}$. Након тога су те
вредности преписане вредностима наведеним у витичастим заградама
`{ a = 3, b = 3, c = 3}`, па је израчунат обим троугла чије све странице имају
дужину $3$, што значи да тај троугао није правоугли.

Значи, у примеру изнад приступ пољима требао је бити ограничен модификатором
приступа `private`:

```cs
class Pravougli
{
    private double a;
    private double b;
    private double c;

    public Pravougli(double katetaA, double katetaB)
    {
        a = katetaA;
        b = katetaB;
        c = Math.Sqrt(katetaA * katetaA + katetaB * katetaB);
    }

    public double Obim()
    {
        return a + b + c;
    }
}
```

Инстанцирање објекта `p1` и израчунавање обима и даље би било коректно, док
инстанцирање објекта `p2` више не би било могуће на овај начин...

```cs
Pravougli p2 = new Pravougli(3.0, 4.0) { a = 3, b = 3, c = 3};
```

и резултирало би грешкама:

* `Error CS0122: 'Pravougli.a' is inaccessible due to its protection level`
* `Error CS0122: 'Pravougli.b' is inaccessible due to its protection level`
* `Error CS0122: 'Pravougli.c' is inaccessible due to its protection level`

Уместо термина "енкапсулација" у литератури на српском језику можеш наићи и на
термин "учауривање", јер се приватни чланови класе "учаурују", тј. "стављају у
чауру" у оквиру које се могу користити.
