# Појам класе

**Класа** представља групу објеката који имају заједничке карактеристике и
функционалности - каже се да је класа апстрактна представа скупа објеката који
имају заједничке карактеристике и функционалности. Класа се декларише на
следећи начин:

```cs
class ImeKlase
{
    // definicija članova klase
}
```

До класа долазиш када уочиш групу објеката који имају заједничке карактеристике
и функционалности. На пример, класа `Ucenik` која описује тебе и твоје другове
из школе, класа `Trougao` која описује све троуглове итд.

Класе имају чланове (енгл. *Class Members*) којима се представљају њихови
подаци и понашање. Чланови класе могу бити:

* поља (енгл. *Fields*),
* константе (енгл. *Constants*),
* методе (енгл. *Methods*),
* својства (енгл. *Properties*),
* конструктори (енгл. *Constructors*),
* догађаји (енгл. *Events*),
* преоптерећени оператори (енгл. *Overloadable Operators*),
* индексери (енгл. *Indexers*),
* угнежђени типови (енгл. *Nested Types*) и
* финализатори (енгл. *Finalizers*).

## Поља

Поља су променљиве декларисане у опсегу класе. Поље може бити неког уграђеног
типа или инстанца друге класе. Пољима се обично представљају подаци ентитета
класе. На пример, поља класе `Trougao` могу бити променљиве којима се
представљају странице троугла: 

```cs
class Trougao
{
    double a;
    double b;
    double c;
}
```

У првом поглављу учио си о
[енкапсулацији](../1_osnovni_koncepti_oop/04_enkapsulacija.md).
Проблем са овако дефинисаним пољима је њихова приступачност из осталих класа.
Да би ова поља ове класе постала приступачна у другим класама, потребно их је
прогласити јавним.

```cs
class Trougao
{
    public double a;
    public double b;
    public double c;
}
```

Да би приступио дефинисаним пољима у главном програму, потребно је да
инстанцираш један објекат класе `Trougao`, па поставиш иницијалне вредности
поља. Након тога можеш да им приступаш, мењаш их, исписујеш итд. На пример:

```cs
using System;

class Trougao
{
    public double a;
    public double b;
    public double c;
}

class Program
{
    static void Main()
    {
        Trougao t1 = new Trougao() { a = 3.0, b = 4.0, c = 4.0 };
        t1.c = 5.0;
        Console.WriteLine("Obim: {0}", t1.a + t1.b + t1.c);
    }
}
```

У примеру изнад инстанциран је објекат `t1` класе `Trougao` са иницијалним
вредностима поља `a = 3.0`, `b = 4.0` и `c = 4.0`. Потом је вредност поља `c`
објекта `t1` (`t1.c`) промењена на `5.0`. У последњој линији у конзоли исписан
је обим троугла као збир вредности поља `a`, `b` и `c` објекта `t1`.

## Константе

Константе су поља чија је вредност унапред задата у програму и која се не може
мењати. На пример, класу `Krug` можеш дефинисати на следећи начин:

```cs
class Krug
{
    public double r;
    public const double pi = 3.14159265359;
}
```

Ради прецизности, у овом случају боље је да вредност константе дефинишеш помоћу
уграђене константе `Math.PI`, него да ручно уносиш децимале:

```cs
public const double pi = Math.PI;
```

У главном програму можеш да инстанцираш један објекат класе `Krug` и пољу `r`
доделиш иницијалну вредност. Дефинисану константу `pi` можеш користити као
константу класе `Krug` (`Krug.pi`), на пример, приликом рачунања
обима круга:

```cs
using System;

class Krug
{
    public double r;
    public const double pi = Math.PI;
}

class Program
{
    static void Main()
    {
        Krug k1 = new Krug() { r = 5.0 };
        Console.WriteLine("Obim: {0}", 2 * Krug.pi * k1.r);
    }
}
```

## Методе

Методе дефинишу радње које класа може да изврши. Методе могу да приме аргументе
дефинисане параметрима, могу да врате податке кроз параметре и могу да врате
вредност директно без коришћења параметара. Једноставан пример методе био би да
у класи `Krug` креираш методу за рачунање обима круга:

```cs
class Krug
{
    public double r;
    public const double pi = Math.PI;

    public double Obim()
    {
        return 2 * r * pi;
    }
}
```

Ова метода нема параметре и враћа вредност директно. У главном програму можеш
да, након инстанцирања објекта `k1` класе `Krug` и доделе иницијалне вредности
пољу `r`, позовеш методу `Obim()` објекта `k1` која ће вратити вредност обима
круга, на пример овако:

```cs
using System;

class Krug
{
    public double r;
    public const double pi = Math.PI;

    public double Obim()
    {
        return 2 * r * pi;
    }
}

class Program
{
    static void Main()
    {
        Krug k1 = new Krug() { r = 5.0 };
        Console.WriteLine("Obim: {0}", k1.Obim());
    }
}
```

Прича о методама је много сложенија, па ћеш о њима учити више у наредним
лекцијама.

## Својства

Својства су методе класе којима се приступа као да су поља класе. На пример,
методу `Obim()` класе `Krug` можеш дефинисати тако да јој се приступа као да је
поље класе. Зашто онда не би, једноставно, дефинисао обим као још једно поље,
на пример `public double O;`? Ако нека величина може да се израчуна на основу
осталих чланова класе, онда није добра пракса да се та величина дефинише као
поље. У овом случају, обим може да се израчуна на основу полупречника и
константе `pi`, те нема потребе да мануелно рачунаш и уносиш и вредност обима
круга.

Значи, својство може да обезбеди заштиту за поље класе како би се спречило да
се његова вредност мења мануелно. У дефиницији својства обично се користе
методе `get()` и `set()` које служе за добављање, односно постављање вредности.
О њима ћеш детаљно учити у наредним поглављима. Методом `get()` могле би се
добавити вредности полупречника `r` и константе `pi` и вратити израчуната
вредност обима круга, на пример овако (komentar: malo ovo jos pojasniti, jer nije najjasnije):

```cs
using System;

class Krug
{
    public double r;
    public const double pi = Math.PI;
    public double O { get { return 2 * pi * r; } }
}

class Program
{
    static void Main()
    {
        Krug k1 = new Krug() { r = 5.0 };
        Console.WriteLine("Obim kruga je: {0}", k1.O);
    }
}
```

Својства ћеш боље упознати касније, нарочито приликом израде *Windows Forms*
апликација.

## Конструктори

Конструктори су специјалне методе које се користе приликом инстанцирања
објеката класе. Имају исто име као и класа у којој су дефинисани и враћају
објекат те класе. Конструктори могу имати различите облике:

* **Подразумевани конструктор без параметара** креира сâм компајлер у
случајевима када класа нема дефинисане конструкторе. То се дешавало у свим
досадашњим примерима.
* **Параметаризовани конструктор** прихвата аргументе који се користе за
иницијализацију поља.
* **Конструктор копије** креира нови објекат као копију постојећег објекта.

Конструктори дефинисани од стране компајлера називају се **имплицитни**
конструктори, док се конструктори дефинисани од стране програмера називају
**експлицитни** конструктори.

Више о конструкторима учићеш у наредним лекцијама.

## Догађаји, преоптерећени оператори, индексери, финализатори и угнежђени типови

Следећи чланови класа биће само поменути у овој лекцији, а више о њима учићеш у
наредним поглављима:

* **Догађаји** представљају механизам за обраду регистрованих активности у
програму, као што су клик на дугме, измена текста у оквиру за текст или нека
друга корисничка или системска активност. Они омогућавају класама да
обавештавају друге делове програма о тим активностима. Такође, програмери могу
дефинисати сопствене догађаје у својим класама.
* **Преоптерећени оператори** су методе које омогућавају да се стандардни
оператори користе са кориснички дефинисаним типовима података. Коришћењем
преоптерећених оператора, програмери могу да дефинишу како оператори раде са
њиховим класама, што омогућава већу флексибилност у програмирању.
* **Индексери** омогућују да се објекти индексирају на начин сличан индексирању
низова. Дефинишу се као методе класе помоћу кључне речи `this`, типом индекса и
методама `get()` и `set()`.
* **Угнежђени типови** су типови декларисани унутар класе. Они могу бити било
који валидан тип података, укључујући основне типове, класе, структуре, низове
итд. Користе се када је потребно да се ограничи коришћење типа или организује
нека логичка структура података унутар класе.
* **Финализатори**, раније познати као **деструктори** (енгл. *destructors*),
данас се веома ретко користе у програмском језику C#. То су методе које се
позивају у тренутку када објекат треба да буде уклоњен из меморије, у циљу
руковања ресурсима који треба да се ослободе. Више их нећемо помињати.
