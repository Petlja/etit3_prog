# Запечаћене класе

До сада си научио више техника које се примењују приликом наслеђивања у
програмском језику C#. У већим пројектима осмишљавање концепта наслеђивања
класа није банална ствар: како осмислити хијерархију класа и само наслеђивање;
шта треба да буде у базним класама, шта у изведеним; да ли треба и када треба
креирати апстрактне класе итд. Једно од питања је и како и када треба
зауставити могућност наслеђивања.

На пример, нека је `Osoba` базна класа. Из класе `Osoba` изводе се класе
`Nastavnik` и `Ucenik`. Из класе `Ucenik` изводе се класе `Redovan` и
`Vanredni`. Из класе `Vanredni` изводе се класе `Prekvalifikacija` и
`Dokvalifikacija` и по тој грани у хијерархији наслеђивања ту мора бити крај. Не
сме да постоји класа која се изводи из класе `Prekvalifikacija` или из класе
`Dokvalifikacija`, односно класе `Prekvalifikacija` и `Dokvalifikacija` не
смеју никад бити базне класе. То се постиже запечаћивањем класа.

Запечаћену класу декларишеш навођењем кључне речи `sealed` пре њене
дефиниције. На пример:

```cs
class Osoba { }
class Ucenik : Osoba { }
class Vanredni : Ucenik { }

sealed class Prekvalifikacija : Vanredni
{
    // clanovi zapecacene klase Prekvalifikacija
}
```

Пошто се класа запечати, више се не може користити као базна класа, односно из
ње се не могу изводити друге класе. Из тог разлога запечаћене класе не могу
бити апстрактне.

Могућност запечаћивања класа доприноси побољшању сигурности и интегритету кода.
Ако желиш да спречиш модификације понашања класе путем наслеђивања,
запечаћивање је добар начин да осигураш да се оригинална имплементација не може
променити.

Запечаћивање класе резултује и бржим извршавањем, јер компајлер зна да се
методе у запечаћеној класи не могу даље наследити и преоптеретити.

## Запечаћени чланови класе

Члан у изведеној класи (метода, индексер, својство или догађај) који
преоптерећује виртуелног члана базне класе може се прогласити запечаћеним.

На пример, ако желиш да спречиш да се мења функционалност надјачане методе
`Mesto` у класи `SrednjaSkola` у некој класи која би била изведена из класе
`SrednjaSkola`, потребно је да наведеш кључну реч `sealed` пре кључне речи
`override`:

```cs
using System;

class Skola
{
    public virtual string Mesto(string mesto)
    {
        return mesto;
    }
}

class SrednjaSkola : Skola
{
    public sealed override string Mesto(string mesto)
    {
        mesto = "Mesto: " + mesto.ToUpper();
        return mesto;
    }
}

class Program
{
    static void Main()
    {
        SrednjaSkola s = new SrednjaSkola();
        Console.WriteLine(s.Mesto("Vrsac"));
    }
}
```

Уколико неко покуша да надјача запечаћени метод, на пример овако...

```cs
class TehnickaSkola : SrednjaSkola
{
    public override string Mesto(string mesto)
    {
        mesto = mesto + ".";
        return mesto;
    }
}
```

...компајлер ће јавити грешку:

```text
CS0239: 'TehnickaSkola.Mesto(string)': cannot override inherited member 'SrednjaSkola.Mesto(string)' because it is sealed
```

Запечаћене методе у програмском језику C# такође доприносе побољшању
интегритета и сигурности кода, као и оптимизацији перформанси.
